# ✅ 第一章《Python 数据模型》核心知识点整理

### 1. **数据模型的作用**

- Python 的数据模型定义了对象如何进行交互（如加法、比较、迭代、属性访问等）。
- 通过实现特殊方法（如 `__len__`, `__getitem__` 等），你可以让自定义对象表现得像内建类型一样。
- 这些特殊方法也被称为“**双下方法**”（dunder methods，即 double underscore methods）。

------

### 2. **Python 的面向协议编程风格**

- 不靠继承接口类，而是使用“**鸭子类型**”：如果一个对象看起来像鸭子、叫起来像鸭子，就可以当作鸭子来使用。
- Python 更看重**行为**而不是**类型**。

------

### 3. **特殊方法的分类**

以下是数据模型中重要的特殊方法类型：

#### 📦 对象创建与销毁

- `__new__(cls, ...)`：创建对象的构造器（少用）。
- `__init__(self, ...)`：初始化对象。
- `__del__(self)`：析构器（谨慎使用）。

#### 🔢 数值运算

- `__add__`, `__sub__`, `__mul__`, `__truediv__`, ...
- 支持运算符重载：允许你自定义 `+`、`*` 等运算行为。

#### 🎲 容器类接口

- `__len__(self)`：支持 `len(obj)`
- `__getitem__(self, key)`：支持 `obj[key]`
- `__setitem__(self, key, value)`：支持赋值 `obj[key] = value`
- `__delitem__(self, key)`：支持 `del obj[key]`
- `__contains__(self, item)`：支持 `in` 语句

#### 🔁 迭代器协议

- `__iter__(self)`：返回一个迭代器对象
- `__next__(self)`：返回下一个元素

#### 🧱 表示与字符串转换

- `__repr__(self)`：开发者调试用的字符串表示
- `__str__(self)`：用户可读的字符串表示
- `__format__(self, format_spec)`：支持格式化字符串
- `__bytes__(self)`：支持 `bytes()` 函数

#### 🔍 属性访问控制

- `__getattr__`, `__setattr__`, `__delattr__`：拦截属性访问、设置、删除
- `__getattribute__`：所有属性访问都会先经过它（非常强大但容易出错）

------

### 4. **为何重视特殊方法**

- 利用这些方法能让你写出**优雅、可复用且 Pythonic 的代码**。
- 它们可以让你创建出“行为上”与内建类型一致的对象，提高 API 的直观性。

------

### 5. **数据模型的哲学影响**

- Python 倾向于简洁、清晰、行为导向。
- 掌握数据模型之后，你可以：
  - 更深入理解 Python 内部如何运作；
  - 定制类的行为；
  - 编写更 Pythonic 的库和类。



------

## 7、 小结

| 类别       | 方法示例                     | 用途              |
| ---------- | ---------------------------- | ----------------- |
| 运算符重载 | `__add__`, `__eq__`          | 支持 `+`, `==` 等 |
| 容器协议   | `__getitem__`, `__len__`     | 支持索引、`len()` |
| 迭代协议   | `__iter__`, `__next__`       | 支持 for 循环     |
| 字符串转换 | `__repr__`, `__str__`        | 支持 `print()`    |
| 属性访问   | `__getattr__`, `__setattr__` | 控制属性逻辑      |

------

# 2、实战与项目介绍

---

## 🧾 Student 项目任务清单

### 📍阶段一：项目初始化与数据结构设计

**目标：构建类的基础结构**

* [ ] 创建类 `Student`
* [ ] 定义用于存储数据的内部结构
* [ ] 实现 `add(name: str, student:Stdent)` 方法，添加学生信息
* [ ] 添加简单异常处理：重复 name 抛出异常

📌 **关键点**：对象封装与初始化方法 `__init__`

---

### 📍阶段二：实现容器协议

**目标：使你的类像内置容器一样工作**

* [ ] 实现 `__getitem__(self, key)` 支持通过索引（int）或名称（str）访问向量

  * 示例：`store[0]` 或 `store["doc1"]`
* [ ] 实现 `__len__(self)` 返回当前存储的向量个数
* [ ] 实现 `__contains__(self, name)` 支持 `"doc1" in store` 判断

📌 **关键点**：容器协议方法：`__getitem__`, `__len__`, `__contains__`

---

### 📍阶段三：实现迭代协议

**目标：支持 for 循环遍历向量**

* [ ] 实现 `__iter__(self)` 返回一个迭代器

📌 **关键点**：迭代协议方法：`__iter__`, 
---

### 📍阶段四：自定义可读性输出

**目标：打印时显示简洁、结构化的对象信息**

* [ ] 实现 `__repr__(self)` 提供开发者友好的调试表示
* [ ] 实现 `__str__(self)` 提供用户友好的格式输出（可打印 name 列表）

📌 **关键点**：字符串表示协议：`__repr__`, `__str__`

---

### 📍阶段五（可选）：进阶功能与挑战

**目标：提升功能性与实用性**

* [ ] 添加 `remove(name: str)` 方法，删除某个向量

📌 **关键点**：进一步练习封装、逻辑判断和简单数值操作

---

## 🎓 任务完成后的收获

| 技能          | 掌握内容                  |
| ----------- | --------------------- |
| 面向对象        | 封装、组合与类的行为设计          |
| 数据模型        | 10+ 个常用 dunder 方法实战应用 |
| Pythonic 思维 | 将你的类自然融入 Python 语言生态  |
| 工程结构        | 理解模块、API 接口设计原则       |

---

