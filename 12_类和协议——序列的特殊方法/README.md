# 一、协议
---

## 1. 静态协议（Static Protocol）

静态协议的意思是：

> **在类型检查阶段就声明并检查协议要求**。
> 通常会用到 `typing.Protocol`（Python 3.8+ 内置，3.5 需要 `typing_extensions`）。

特点：

* **显式**：你定义一个协议类，明确列出必须的方法和属性。
* **可被静态类型检查器识别**（如 `mypy`, Pyright）。
* **不需要继承实现类**，只要方法签名匹配，就被认为遵循协议。

例子：

```python
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> None: ...

class Circle:
    def draw(self) -> None:
        print("Drawing Circle")

def render(obj: Drawable):
    obj.draw()

render(Circle())  # ✅ 静态检查通过
```


## 2. 动态协议（Dynamic Protocol）

动态协议就是 Python 的**鸭子类型协议**：

> 只要对象在运行时具有所需的方法/属性，就认为它符合协议。
> 不需要提前声明，也没有静态检查，解释器直接调用。

特点：

* **完全运行时决定**。
* 无类型提示时更灵活，但风险是方法缺失要到运行时才报错。
* 实现方式：直接在类中定义协议要求的方法。

例子：

```python
class Square:
    def draw(self):
        print("Drawing Square")

def render(obj):
    obj.draw()

render(Square())  # ✅ 运行时正常
```

如果传入一个没有 `draw()` 方法的对象，运行时才会抛出 `AttributeError`。

---

## 3. 对比表

| 特性       | 静态协议 (Static Protocol)    | 动态协议 (Dynamic Protocol) |
| -------- | ------------------------- | ----------------------- |
| **检查时机** | 编译/类型检查阶段                 | 运行时                     |
| **声明方式** | 通过 `typing.Protocol` 显式声明 | 不声明，直接实现方法              |
| **继承要求** | 无需继承协议类                   | 无需继承任何类                 |
| **安全性**  | 高（提前发现错误）                 | 中（运行时才报错）               |
| **灵活性**  | 中（需方法签名匹配）                | 高（方法名、签名都可灵活变化）         |
| **适用场景** | 大型团队项目、接口稳定需求高的场景         | 脚本、小型项目、原型快速开发          |


# 二、序列切片

---

## 1. slice 是什么？

`slice` 是 Python 内置的一个**切片对象类型**，专门用来保存切片的**起点、终点、步长**信息。
当你写：

```python
seq[2:8:2]
```

解释器实际上会构造一个：

```python
slice(2, 8, 2)
```

然后调用：

```python
seq.__getitem__(slice(2, 8, 2))
```

---

## 2. indices 是什么？

`slice.indices()` 是 `slice` 对象的一个方法，用来把切片的 `start`、`stop`、`step` **转换成在某个序列长度范围内的有效整数索引**。
它会：

* 处理 `None`（比如没写起点/终点）
* 处理负数索引
* 限制在 `[0, length]` 范围内，防止越界

语法：

```python
slice_obj.indices(sequence_length)
```

返回 `(start, stop, step)` 三元组。

---

## 3. 为什么需要 `indices()`？

因为切片本身是懒的，它的 `start`、`stop` 可能是：

* `None`
* 负数
* 超过序列长度
* 配合 `step` 需要计算实际可迭代范围

`indices()` 会在**给定长度的序列上下文中**，算出最终的整数范围。

---

## 4. 举例

```python
s = slice(-3, 100, 2)  # 起点是倒数第三，终点超长
result = s.indices(10) # 序列长度是 10
print(result)
```

输出：

```
(7, 10, 2)
```

解释：

* 长度是 10 → 索引范围 `[0, 9]`
* 起点 -3 → 转成 `10 - 3 = 7`
* 终点 100 → 超长 → 截成 10
* 步长保持 2

所以实际取的就是 `seq[7:10:2]`。

---

## 5. 总结对比

| 概念          | 作用                          |
| ----------- | --------------------------- |
| `slice`     | 存储切片的起点、终点、步长信息（逻辑层面）       |
| `indices()` | 把 `slice` 参数映射成实际整数索引（物理层面） |

---

# 三、零碎知识
## 1.property装饰器

`@property` 是 Python 提供的一个内置装饰器，用来把方法包装成“像属性一样访问”的东西。

### 1. 核心作用

> 用方法来计算或控制访问，但调用时表现得像访问属性一样。
> 好处：外部调用者用点号访问，不需要加括号。


### 2. 为啥要用 @property

* **封装**：一开始可能只是个简单字段，后来需要加计算逻辑，也不用改外部调用方式。
* **只读属性**：防止外部直接修改。
* **延迟计算**：等访问时才执行计算（懒加载）。
* **输入校验**：配合 setter 可以限制赋值条件。

---

### 3. 注意事项

* `@property` 方法不能有参数（除了 `self`），因为属性访问时不能传参。
* 如果计算量很大又会频繁调用，可以考虑 `functools.cached_property`（Python 3.8+）。
* 不要滥用，否则会让属性行为变得不可预测。

## 2. 映射过程 和 规约过程

---

### 1. 映射过程（Mapping）

**定义**

> 把一个函数应用到可迭代对象的**每个元素**，得到一个**新的可迭代对象**（通常是一一对应的变换）。

**特点**

* 输入：一个可迭代对象（列表、元组、生成器…）
* 输出：等长的可迭代对象（每个元素被加工过）
* 不改变原数据（纯函数化场景下）

**数学类比**
如果 $f(x) = x^2$，那映射就是：

$$
[1, 2, 3] \xrightarrow{f} [1, 4, 9]
$$

**Python 实现方式**

```python
nums = [1, 2, 3]
# 用 map()
squares = map(lambda x: x**2, nums)
print(list(squares))  # [1, 4, 9]

# 或者用列表推导式（推荐，可读性高）
squares = [x**2 for x in nums]
```

---

### 2. 规约过程（Reduction）

**定义**

> 把一个可迭代对象**按照某种规则合并成单一结果**，通常是递归地**两两合并**直到只剩一个值。

**特点**

* 输入：一个可迭代对象
* 输出：一个单一值
* 需要**二元函数**（接收两个参数，返回一个值）

**数学类比**
求和：

$$
[1, 2, 3, 4] \xrightarrow{+} (((1+2)+3)+4) = 10
$$

**Python 实现方式**

```python
from functools import reduce

nums = [1, 2, 3, 4]
total = reduce(lambda x, y: x + y, nums)
print(total)  # 10
```

---

### 3. 区别对比

| 特性           | 映射 (Mapping) | 规约 (Reduction)            |
| ------------ | ------------ | ------------------------- |
| **作用**       | 元素逐个变换       | 全部合并成一个值                  |
| **函数参数**     | 接收一个参数       | 接收两个参数                    |
| **输出**       | 新的可迭代对象      | 单个值                       |
| **长度关系**     | 输入输出等长       | 输出长度恒为 1                  |
| **Python工具** | `map()`、推导式  | `functools.reduce()`、循环累积 |

## 3.构造函数是用来创建并初始化对象的方法。函数签名是对一个函数“如何被调用”的完整描述
**⚽函数签名:**

函数名

参数列表（顺序、名称、默认值、类型注解）

可变参数（*args, **kwargs）

返回值类型注解（如果有）

它不关心函数的内部实现，只关心调用接口。
## 4.杂谈
1. 组合模式是指 —— 用统一的方式处理单个对象和由多个对象组合的结构
2. 协议是一组方法的约定，如果实现了某些方法，就认为遵循某种协议，而无需继承类。协议是非正式的，
没有强制力，因此如果知道类的具体使用场景，那么通常只需要实现协议的一部分。
3. slice :  切片的本质。[1:4:2]会生成slice(1,4,2).indice(len(对象)),其中indice旨在告诉解释器切片对象的长度，以便能够正确
处理负数索引。
4. __getattr__是一种后备机制，仅当对象没有指定名称的属性时，python才会调用该方法生成该属性。
5. all函数里面的元素都为True，或者为空时才会返回True，否则返回False。这涉及到了“真值的空积原则”——
集合为空时，没有反例可以让他为假，因此为真。
6. zip函数，需要注意的是，它并不要求两个对象长度一致，当另一个可迭代对象耗尽时就会停止，而不报错。