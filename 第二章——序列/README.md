## 1.序列的分类
| 类型    | 是否可变     | 示例                                         |
| ----- | -------- | ------------------------------------------ |
| 容器序列  | 可变 / 不可变 | `list`, `tuple`, `collections.deque`       |
| 扁平序列  | 不可变      | `str`, `bytes`, `bytearray`, `array.array` |
| 可变序列  | ✅        | `list`, `bytearray`, `deque`               |
| 不可变序列 | ❌        | `tuple`, `str`, `bytes`                    |
1. 容器序列存放的是所包含对象的引用，对象可以是任何类型。 扁平序列在自己的内存空间中存储所包含的
内容的值， 而不是各自不同的python对象。因此，扁平序列更加紧凑，但是只能存放原始机器值，例如字节、
整数和浮点数。任何python对象在内存中都有一个包含元数据的标头。
✔️元数据是指用于描述其他对象的性质和特征的数据。
2. 元组的每一项都是引用，引用的是不同的python对象，而这些对象又可以存放其他python对象的引用。

## 2.列表推导式和生成器表达式
1. python会忽略[],{},()的内部的换行，因此内部数据可以直接分几行来书写，不需使用续行转义符。另外，在定义
字面量时，项与项之间的使用逗号分隔、末尾的逗号会被忽略。因此，最好在末尾添加一个逗号，减少代码差异带来的阅读干扰。
2. 对于生成器而言，只是最外层由[]变味了()。

## 3. 元组特性
1. 元组可以作为不可变列表使用，也可以作为没有字段名称的记录。
2. 给定一个元组t，tuple(t)会直接返回t的引用，不涉及复制。相比之下，给定一个列表l，list(l)则会创建l的副本。
3. tuple实例长度固定，分配的内存空间正好够用，而list实例的内存空间要富余一些。
4. 对元组中项的引用存储在元组结构体中的一个数组中，而列表把引用数组的指针存储在别处。
✔️具名字段是指字段(数据属性)带有名字，而不是仅靠位置来访问。
✔️引用是变量与变量之间的一种间接绑定关系。在python中，变量不直接存储对象本身，而是存储一个指向对象的引用。
✔️元组本质上是用逗号分割的一组值，与括号无关。

## 4.序列模式匹配
1. match-case语句可以匹配对象，但是str、bytes、batearray实例不作为序列来处理，match会把他们视为“原子值”，
即把他们视为一个整体来处理。
2. _符号很特殊，会匹配相应位置上的任何一项，但不绑定到值，且可以重复出现。_会匹配一项，*_会匹配任意数量的项。
3. 模式中的任何一部分都可以通过as关键字绑定到变量上面。一个序列模式只能有一个*
4. 对于不可变序列重复拼接效率低下，因为解释器必须复制整个目标序列，创建一个新序列，包含要拼接的项，而不是简单追加项
5. list.sort会就地排序，sorted会返回新创建的列表。
6. 如果你在代码中需要经常加纳查容器中是否存在某一类项，应该考虑使用set容器,set是可迭代对象，但不是序列，因为set中的项是无序的。
7. 如果一个列表只有数值并且数值数量非常多，可以考虑使用array数组，python对他进行了优化。

---
## 实战训练
本次实战基于第一章的学生信息管理，增加了handle_info和new方法