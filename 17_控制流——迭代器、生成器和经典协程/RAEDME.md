
## 1. in 的原理

当你写 "hello" in temp 时，Python 会做以下几步：
检查 temp 是否有 __contains__ 方法：
如果有，就直接调用 temp.__contains__("hello")。
否则，看 temp 是否是可迭代对象（有没有 __iter__ 方法）：
有的话，就用 iter(temp) 得到一个迭代器(字符串迭代器会逐个取出字符)。
然后不断调用 next()，逐个比较元素是否等于 "hello"。
如果都不满足，会抛 TypeError。

## 2. 列表推导式和生成器表达式

### 1. 列表推导式：及早生成 (eager evaluation)

```python
lst = [x*x for x in range(5)]
print(lst)
```

输出：

```
[0, 1, 4, 9, 16]
```

特点：

* **一次性**把所有结果都算出来，存放到列表里。
* 占用内存 = `结果数量 * 单个元素大小`。
* 访问任意元素时是 O(1)（因为已经存在内存里）。

⚠️ 如果结果很大，比如 `[x for x in range(10**8)]`，会直接占用非常多内存。

---

### 2. 生成器表达式：惰性生成 (lazy evaluation)

```python
gen = (x*x for x in range(5))
print(gen)          # 只是一个生成器对象
print(next(gen))    # 0
print(next(gen))    # 1
```

特点：

* 不会立刻算出所有结果，而是 **用到一个，算一个，扔一个**。
* 内存占用极小（只存当前状态，比如迭代器的位置）。
* 只能遍历一次，遍历完了就没了。

适合 **大数据量** 或 **流式数据处理**。

---

### 3. 对比总结

| 特性    | 列表推导式            | 生成器表达式     |
| ----- | ---------------- | ---------- |
| 求值方式  | 及早生成（一次性计算出所有元素） | 惰性生成（用到才算） |
| 内存占用  | 与结果大小成正比         | 只占少量内存     |
| 可迭代次数 | 多次（因为是列表）        | 一次（遍历后就没了） |
| 性能    | 小数据时快            | 大数据时更节省资源  |

---

📌 打个比喻：

* **列表推导式** = 一次性把所有菜都做好，摆满桌子。
* **生成器表达式** = 你点一道菜，厨师现炒一道。

---

## 3. iter() 函数调用机制
1. 检查对象是否实现了__iter__方法，如果实现了就调用它，获取一个迭代器。
2. 如果没有实现__iter__方法，但是实现了__getitem__方法，那么iter（）就会创建一个迭代器，
尝试按索引（从0开始）获取项。（之所以通过__getitem__方法迭代，是为了向后兼容，所以说实现了该方法一样会被视为可迭代对象。）
3. 如果尝试失败，则python抛出异常。
4. iter()函数接收两个参数——第一个参数必须是一个可迭代对象，第二个参数是哨符，即标记值，如果可调用对象返回哨符，则迭代器抛出 `StopIteration`，不产生哨符。
5. 迭代器不是从已有“现成数据”里取，而是 每次主动调用函数生成新数据。

---

## 4. 杂谈

1. 检查某个对象是否能够迭代，最准确的方法就是调用 iter()函数，如果不可迭代就会发出异常信息。因为iter（）还会兼容实现了__getitem__的类。



## 4. 可迭代对象和迭代器

1. python从可迭代对象中获取迭代器。可迭代对象 —— 实现了__iter__或__getitem__方法的对象。
2. 迭代器 —— 实现了 __next__ (返回序列中的下一项，没有项就会抛出`StopIteration`)和__iter__(返回 `self`)方法的对象。
3. 迭代器实现了 __iter__，所以它本身是可迭代对象。
语义上：迭代器一次性，而我们通常把“可迭代对象”理解为“可以反复遍历的容器”，所以会区分开来。
4. 二者之间的一大差别在于:迭代器是一次性的，用完就没了，可迭代对象则可以重复使用。

## 5. 生成器

1. 生成器函数会创建一个生成器对象，包装生成器函数的主体。把生成器对象传给 next()函数时，生成器函数提前执行函数主体中的下一个
yield语句，返回产出的值，并在函数主体的当前位置暂停。最终，函数的主体返回时，python创建的外层生成器返回`StopIteration`。
2. `yield from`表达式语法可以把一个生成器的工作委托给子生成器。其中，委托生成器作为中介，可以把外部调用方与子生成器直接连接，使得二者可以直接交互（包括 send()、throw() 等）。
子生成器 return 的值可以被捕获。
3. 生成器和迭代器的对比

### 1. 基本定义

| 类型                  | 定义                                  | 是否迭代器 | 是否可迭代 |
| ------------------- | ----------------------------------- | ----- | ----- |
| **迭代器 (iterator)**  | 实现了 `__next__()` 和 `__iter__()` 的对象 | ✅     | ✅     |
| **生成器 (generator)** | 一种特殊的迭代器，通过 `yield` 产生值             | ✅     | ✅     |

**结论**：
生成器 **本质上就是一种迭代器**，所以生成器可以直接用 `for` 循环或 `next()` 遍历。

---

### 2. 迭代器特点

* **一次性**：用完就没了，需要重新生成才能再遍历。
* **手动或自动生成**：

  * 手动：自定义类实现 `__next__`。
  * 自动：调用 `iter(some_iterable)`。
* **例子**：

```python
lst = [1, 2, 3]
it = iter(lst)   # 迭代器
print(next(it))  # 1
print(next(it))  # 2
```

---

### 3. 生成器特点

* **通过 `yield` 定义**，每次 `yield` 返回一个值。
* **语法简洁**：不用写 `__next__`、`__iter__`，Python 自动帮你生成迭代器对象。
* **惰性求值**：每次迭代才计算下一步结果，不像列表一次生成所有元素。
* **例子**：

```python
def gen():
    for i in range(3):
        yield i

g = gen()        # 生成器对象
print(next(g))   # 0
print(next(g))   # 1
```

* **特性**：

  * 可以用 `for` 循环遍历
  * 可以用 `send()` 向生成器传值
  * 一次性使用

---

### 4. 迭代器 vs 生成器对比

| 特性    | 迭代器            | 生成器             |
| ----- | -------------- | --------------- |
| 定义方式  | 类实现 `__next__` | 函数用 `yield`     |
| 是否迭代器 | ✅              | ✅               |
| 是否可迭代 | ✅              | ✅               |
| 一次性   | ✅              | ✅               |
| 惰性求值  | 可实现            | 默认惰性            |
| 代码复杂度 | 高，需要手动维护状态     | 低，Python 自动维护状态 |
| 可发送值  | ❌              | ✅（`send()`）     |

---

### 5. 总结关系

* **迭代器是概念**，生成器是实现方式之一。
* **生成器 = 写迭代器的快捷方式**，可以动态生成序列，语法更简洁。
* 迭代器可以通过生成器函数快速创建，而不需要手动写类。

---

## 6. 可迭代对象、迭代器和生成器，三者之间的联系
---


### 1. **概念定义**

| 名称                   | 定义                                  | 特点                  | 是否可迭代 | 是否一次性        |
| -------------------- | ----------------------------------- | ------------------- | ----- | ------------ |
| **可迭代对象 (iterable)** | 实现了 `__iter__()` 的对象                | 可以生成迭代器             | ✅     | ❌（通常可以重复迭代）  |
| **迭代器 (iterator)**   | 实现了 `__iter__()` 和 `__next__()` 的对象 | 通过 `next()` 获取下一个值  | ✅     | ✅（一次性，用完就耗尽） |
| **生成器 (generator)**  | 用 `yield` 定义的函数或生成器表达式返回的对象         | 本质上是迭代器，惰性求值，自动维护状态 | ✅     | ✅（一次性）       |

---

### 2. **形象化**

* **可迭代对象** = 糖盒，你可以拿出一个迭代器，多次取糖，每次都有新传送带。
* **迭代器** = 传送带，一次性，糖用完就没了。
* **生成器** = 自动化传送带，你写生产步骤，Python 自动生成迭代器，每次需要糖时才生产。


## 7. 协程（coroutine）把“经典协程”和“原生协程”的区别

### 1. **协程（Coroutine）概念**

* **定义**：协程是一种**用户态的轻量级线程**，可以在执行过程中**暂停并让出控制权**，然后在适当的时候**恢复执行**。
* **特点**：

  1. **非抢占式**：协程切换由程序控制，而不是操作系统调度。
  2. **轻量级**：一个线程中可以运行成百上千个协程。
  3. **适合 IO 密集型任务**：如网络请求、文件读写、异步计算。

> 简单比喻：协程就像“可暂停的函数”，你可以在中途停下来处理别的事情，然后再回来继续执行。

---

### 2. **经典协程（Generator-based Coroutine）**

* **Python 早期协程**，基于 **生成器 (`yield`)** 实现。
* **原理**：用 `yield` 暂停函数，把控制权交给调度器或外部调用方。

* **特点**：

  1. 使用 `yield` 暂停和接收外部数据。
  2. 需要 **手动预激活**（调用一次 `next()`）。

* **用途**：

  * 异步 IO 框架（如旧版 asyncio）
  * 流程控制、生产者-消费者模型

---

### 3. **原生协程（Native Coroutine）**

* **Python 3.5+** 引入 **`async def` / `await`** 语法
* **定义**：直接用 `async def` 定义函数，返回一个协程对象，可用 `await` 暂停等待另一个协程完成。
* **特点**：

  1. 不需要手动预激活，Python 自动管理。
  2. 可以直接 `await` 其他协程，支持链式调用。
  3. 与 `asyncio`、异步框架天然兼容。

* **用途**：

  * 异步网络请求（aiohttp）
  * 异步文件操作
  * 高并发 IO 场景

---

### 4. **经典协程 vs 原生协程对比**

| 特性        | 经典协程            | 原生协程                  |
| --------- | --------------- | --------------------- |
| 实现方式      | 基于生成器 `yield`   | 基于 `async/await`      |
| 预激活       | 需要 `next()`     | 自动管理                  |
| 可嵌套调用     | 需要 `yield from` | 可直接 `await`           |
| 语法清晰度     | 相对复杂            | 清晰直观                  |
| Python 版本 | 3.3+            | 3.5+                  |
| 应用        | 小型异步任务、教学演示     | 现代 asyncio、网络 IO、并发任务 |

---

💡 **总结**：

* **协程** = 可以暂停的函数
* **经典协程** = 用 `yield` 做协程
* **原生协程** = 用 `async def` + `await` 做协程，更现代、更强大
* **中止协程** ：可以通过.close()方法直接取消引用，因为一旦没有对生成器·的有效引用，生成器就会被当作垃圾回收。

---

## 8. yield新用法
### 1. 第一次要`next()` 或 `send(None)`，进行生成器启动。

* 当你调用生成器函数（`gen()`）时，它只是**返回一个生成器对象**，**不会执行函数体**。

```python
def gen():
    x = yield 10
```

* 此时生成器还没有到 `yield` 语句的位置。
* 你必须先**把生成器“推进到第一个 yield”**，才能让它暂停，准备接收 `send()` 传入的值。

```python
g = gen()
next(g)        # 启动生成器，执行到 yield 10 暂停
```

### 2. .send()方法

* `yield` 不只是“产出值”，在 **赋值语法**下，它本身是一个表达式：

```python
received = yield value
```

* 执行过程：

1. 生成器暂停在 `yield value`，把 `value` 输出给外部。
2. 外部调用 `send(some_val)` 继续生成器执行
3. **`yield value` 表达式的结果就是 `send()` 传入的值**
4. 所以 `received = yield value` → `received = some_val`

> 可以理解为：
>
> * `yield value`：生成器“抛出”一个值给外部
> * `send(val)`：外部“送回”一个值给生成器
> * 这个值就成为 `yield` 表达式的返回值

---

 **示例**

```python
def gen():
    print("Start")
    x = yield 10   # 暂停，输出 10
    print("x received:", x)
    y = yield 20
    print("y received:", y)

g = gen()
print(next(g))     # 启动生成器，输出 10
print(g.send(99))  # send 99 给 x，输出 "x received: 99"，产出 20
g.send(88)         # send 88 给 y，输出 "y received: 88"
```

**输出：**

```
Start
10
x received: 99
20
y received: 88
```
### 3.小结
yield value 的 value 部分是“要给外部的值”。

received = yield value 是最常见的写法，因为你同时要：

给外部一个值（value）；

在内部拿到外部下次传回来的值（received）。

如果你只写 received = yield：

外部拿到的是 None，

内部还是能通过 received 接收到 send 的值。

