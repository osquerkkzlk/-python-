
---

## 1. 核心概念

* **运算符重载** = 通过实现特殊方法，让内置运算符（+、-、\*、\[]、in、== 等）在自定义类上有特定行为。
* 特殊方法是双下划线开头结尾的（`__add__`, `__getitem__` 等）。
* 运算符重载的目的是**让你的类像内置类型一样自然使用**。

---

## 2. 常见特殊方法分类

### (1) 算术运算

| 运算符  | 方法                     | 备注   |
| ---- | ---------------------- | ---- |
| `+`  | `__add__(self, other)` | 正向加法 |
| `-`  | `__sub__`              | 减法   |
| `*`  | `__mul__`              | 乘法   |
| `/`  | `__truediv__`          | 真除法  |
| `//` | `__floordiv__`         | 地板除  |
| `%`  | `__mod__`              | 取模   |
| `**` | `__pow__`              | 幂运算  |

> **反向运算**：`__radd__`, `__rsub__`, ...（当左操作数不支持该运算时调用）
> **增强赋值**：`__iadd__`, `__imul__` 等（+=、\*=）

---

### (2) 比较运算

| 运算符  | 方法       |
| ---- | -------- |
| `<`  | `__lt__` |
| `<=` | `__le__` |
| `==` | `__eq__` |
| `!=` | `__ne__` |
| `>`  | `__gt__` |
| `>=` | `__ge__` |

> 如果只实现了部分方法，可以用 `functools.total_ordering` 自动补全。

---

### (3) 容器协议

| 功能   | 方法                              | 说明                 |
| ---- | ------------------------------- | ------------------ |
| 索引取值 | `__getitem__(self, key)`        | `obj[key]`         |
| 索引赋值 | `__setitem__(self, key, value)` | `obj[key] = value` |
| 删除   | `__delitem__`                   | `del obj[key]`     |
| 长度   | `__len__`                       | `len(obj)`         |
| 成员测试 | `__contains__`                  | `x in obj`         |

---

### (4) 可调用对象

| 功能   | 方法                                |
| ---- | --------------------------------- |
| 函数调用 | `__call__(self, *args, **kwargs)` |

---

### (5) 其他常用

| 功能    | 方法                                |
| ----- | --------------------------------- |
| 字符串表示 | `__str__`（用户可读），`__repr__`（开发者调试） |
| 上下文管理 | `__enter__`, `__exit__`           |
| 布尔值   | `__bool__`                        |

---

## 3. 注意事项

1. **返回新对象 vs 修改原对象**

   * `__add__` 通常返回新对象
   * `__iadd__`（+=）可以就地修改
2. **与内置类型交互**

   * 要支持不同类型操作（如 `Vector + int`），需要在方法里处理 `isinstance`，或者实现反向运算。
3. **不要滥用**

   * 过度重载会让代码难以理解（比如用 `*` 表示不相关的操作）。
4. **遵循语义一致性**

   * `a == b` 应该和 `not (a != b)` 结果一致，否则会让人困惑。

---

## 4. 小例子：向量加法

```python
class Vector:
    def __init__(self, x, y):
        self.x, self.y = x, y

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented

    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)  # Vector(4, 6)
```

---

## 5. 杂谈
1. 当增量运算符的接收者是可变对象时，讲新建实例，重新绑定左边变量。
2. 一元运算符和中缀运算符的结果应该是新对象，绝不能修改操作数。为了支持其他类型，可以返回特殊的NotImplemented值，而不是异常，
让解释器尝试对调操作数，然后调用运算符的反向特殊方法（例如__radd__）。