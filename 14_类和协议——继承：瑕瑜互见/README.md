# 一、super函数

1. super().__init__可以让超类完成它的初始化任务，super()有两个可选参数，分别是type(从哪里开始搜素
实现所需要的方法的超类，默认为super()调用所在的类) 和 object_or_type(接受方法调用的对象或类，在实例方法中，默认为self)。
super()会在type参数指定的超类中寻找一个方法，把他绑定到object_or_type上面，因此带哦用该方法时不用显示地传入接收者self。
2. ** MRO **—— 是python在处理继承时确定的方法或属性查找顺序的规则，它定义了当调用一个方法或访问一个属性时，python如何在
类和超类中查找目标的方法的顺序。

3. 直接子类化内置类型（e.g. dict、list）容易出错，因为内置类型的方法通常会忽略用户覆盖的方法，不要子类化内置类型，用户自己定义的类因该继承collections模块中的方法，
例如UserDict、USerList等。这些类做了特殊设计，因此易于扩展。

---

# 二、多重继承和方法解析顺序

1. 多重继承 —— 一个类继承多个超类（包括混入类），从而获得所有超类的属性、方法。
2. 每个类都有一个_mro_属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直到object类。
3. 方法解析顺序只决定唤醒顺序，至于各个类中相应的方法是否被唤醒，则取决于实现方法有没有调用super()。
调用super()的方法叫做类协作，利用类协作可以实现协作多继承。
4. 在多重继承中，如果一个类（MRO中前面的类覆盖了一个方法，但是未调用super()超类方法，那么MRO中的后续类的同名方法不会被执行）
5. 混入类 —— 是一种特殊类，不单独使用或实例化，通过多重继承为其他类提供可复用的功能或行为（一个类可能继承一个主超类，和多个混入类），
为了让混入类发挥作用，在子类的解析方法中，他要出现在其他类前面。也就是说，在类声明语句中，混入类必须出现在基类元组的第一位。

如果一个类的作用是提供方法实现以供多个不先关的类复用，但不体现“是什么”关系，那么就应该吧那个类明确地定义为混入类。从定义上讲，
混入不定义新类型，只是打包方法，便于重用。具体类不能只继承混入类。混入类应该提供某方面的特定行为，只实现少量关系非常紧密的方法。混入类不应保持任何内部状态，即不应具有实例属性。
6. 对象组合 —— 一个类持有另一个类实例，低耦合，相当灵活。因此，推荐使用对象组合，因为类继承高耦合，不易修改。