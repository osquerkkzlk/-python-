
---

## ✅ 第六章知识结构：对象引用、可变性与垃圾回收

---

### 📌 [一、变量不是盒子，是标签（绑定机制）]()

> 在 Python 中，**变量是对象的引用**，而不是对象本身。

```python
a = [1, 2, 3]
b = a
b.append(4)
print(a)  # [1, 2, 3, 4] —— a 和 b 指向的是同一个列表对象
```

---

### 📌 二、标识、相等性与别名（id、== 与 is）

* `id(obj)`：对象的内存地址（唯一标识）
* `==`：值相等（通过 `__eq__` 方法比较）
* `is`：身份相等（引用同一对象）

```python
a = [1, 2]
b = a
c = [1, 2]

a == c  # True（值相等）
a is c  # False（不是同一个对象）
```

---

### 📌 三、可变对象与不可变对象

#### 不可变类型：

* `int`, `float`, `str`, `tuple`, `frozenset`

#### 可变类型：

* `list`, `dict`, `set`, 自定义类对象等

✅ 重点：元组本身是不可变的，但**可以包含可变对象**：

```python
t = (1, [2, 3])
t[1].append(4)
print(t)  # (1, [2, 3, 4])
```

---

### 📌 四、函数参数传递机制：**按对象引用传递（call by sharing）**

> 参数传递时，**函数获得的是参数的引用（地址），不是拷贝**。

```python
def modify(lst):
    lst.append(99)

nums = [1, 2, 3]
modify(nums)
print(nums)  # [1, 2, 3, 99] —— 原列表被修改
```

---

### 📌 五、浅拷贝 vs 深拷贝（copy模块）

* 浅拷贝（`copy.copy()`）：只复制最外层对象，内层对象仍是引用
* 深拷贝（`copy.deepcopy()`）：递归复制所有嵌套对象，完全独立

```python
import copy
a = [[1, 2], [3, 4]]
b = copy.copy(a)
c = copy.deepcopy(a)
```

---

### 📌 六、垃圾回收与引用计数（GC）

Python 使用 **引用计数 + 垃圾回收机制** 来管理内存：

* 每个对象维护一个引用计数器；
* 当引用数为 0，自动释放；
* 避免循环引用使用 `gc` 模块。

```python
import gc
gc.collect()  # 手动触发垃圾回收
```

---

### 📌 七、弱引用（weakref 模块）

> 弱引用不会增加引用计数。常用于缓存或观察者模式。

```python
import weakref
class Car: pass

c = Car()
ref = weakref.ref(c)
print(ref())  # <__main__.Car object>
del c
print(ref())  # None —— 被回收了
```

---
### 八、杂谈
1. 面向对象是指用对象去组织代码，关注谁来做;面向过程是指按步骤编写代码，关注怎么做
2. 引用变量:变量保存的是对象的引用（地址），而不是对象本身的值
3. python的赋值语句，应该始终先读右边。对象现在右边创建或获取，然后左边的变量才会绑定到变量上。就像给对象贴上标签一样。
4. 变量只不过是标注，所以即使为对象贴上多个标注也是可行的，多出来的标注就是别名
5. id()可以返回对象的内存地址。我们通常用is比较对象的标识，即标识符是否指向同一块内存单元。
6. 元组具有相对不可变性：元组（同大多数容器一样）存储的是对象的引用，如果引用的项是可变的，那么项依旧可以被更改。也就是说元组的不可变性

其实是指 tuple 数据结构的物理内容（存储的引用）不可变，与引用的对象无关。[也就是说，元组的项的引用不可更改，但是引用对象可以更改]()
7. 扁平序列, e.g.str...存储的不是引用，而是在连续的内存中存储内容本身（字符、字节序列和数值）
8. 内置的类型构造函数，如list、set等或 [:] ,默认是做浅拷贝(赋复制最外层容器,但副本中的项是原容器中项的引用)
浅拷贝：简单对象创建，复杂对象继续引用（🪼当进行插入操作时，不可变对象会重新创建，可变对象会被继续引用）。
深拷贝：副本不共享内部对象的引用。
9. 函数的参数是引用，即共享传参（指函数的形参会获得实参引用的副本。也就是说函数内部的形参是实参的别名），这就意味着函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即无法彻底改变一个对象）。
10. 默认参数值只会在函数定义时求值一次。 如果这个默认值是一个可变对象（例如 [] 或 {}），那么所有函数调用都会共享这一个对象。所以我们一般把None作为可变值参数的默认值。
11. 对象不会自行销毁，当对象不可达时会被当作垃圾回收。del语句删除的是引用，而不是对象，当对象不可达时就会被删除。[垃圾回收的主要算法是计数，当计数归零，对象立刻销毁]()
12. 对于元组来讲，tuple()或者[:]仍然会获得同一个引用，而对于字面量（常量）重复调用,也会返回同一个引用，而不去创建副本。



---
## 🔁 总结：

| 概念    | 特点                             |
| ----- | ------------------------------ |
| 对象引用  | 变量是标签，指向对象                     |
| 可变性   | 是否支持原地修改                       |
| 相等性   | == 比较值，is 比较引用                 |
| 浅/深拷贝 | copy.copy() vs copy.deepcopy() |
| GC机制  | 引用计数 + 自动垃圾回收                  |
| 弱引用   | 不增加引用计数，避免内存泄露                 |

---
